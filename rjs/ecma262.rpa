#!emitall
#!emitnone
#!emit BitwiseANDOp
#!emit BitwiseXOROp
#!emit BitwiseOROp
#!emit AdditiveExpressionOp
#!emit MultiplicativeExpressionOp
#!emit ShiftExpressionOp
#!emit EqualityExpressionOp
#!emit RelationalExpressionOp
#!emit LogicalOROp
#!emit LogicalANDOp

#!emit AssignmentOperator
#!emit EqualityOperator
#!emit RelationalOperator
#!emit AdditiveOperator
#!emit MultiplicativeOperator
#!emit ShiftOperator
#!emit BitwiseANDOperator
#!emit BitwiseXOROperator
#!emit BitwiseOROperator
#!emit LogicalANDOperator
#!emit LogicalOROperator
#!emit LogicalNotOperator
#!emit BitwiseNotOperator
#!emit UnaryOperator

#!emit PrefixOperator
#!emit PostfixOperator
#!emit PostfixExpressionOp
#!emit PrefixExpressionOp

#!emit UnaryExpressionOp
#!emit LogicalNotExpressionOp
#!emit BitwiseNotExpressionOp

#!emit DecimalIntegerLiteral
#!emit DecimalNonIntegerLiteral
#!emit Block

#!emit DoKeyword
#!emit IterationDo

#!emit sqstring
#!emit dqstring
#!emit DoubleStringCharacters
#!emit SingleStringCharacters
#!emit Program
#!emit Initialiser
#!emit AssignmentExpressionOp
#!emit AssignmentExpression
#!emit LeftHandSideExpression
#!emit LeftHandSideExpressionAddr
#!emit Expression
#!emit MemberExpressionIndexOp
#emit MemberExpression
#emit NewExpression
#!emit MemberExpressionDotOp
#!emit IdentifierName
#!emit Identifier
#!emit CallExpression
#!emit VariableAllocate
#!emit VariableAllocateAndInit
#!emit NewArrayExpression
#!emit FunctionName
#!emit FunctionDeclaration
#!emit FunctionParameter
#!emit FormalParameterList
#!emit Argument
#!emit Arguments
#!emit FunctionCall
#!emit FunctionCallName
#!emit ReturnStatement
#!emit IfStatement
#!emit IfConditionOp
#!emit IfTrueStatement
#!emit IfFalseStatement
#!emit IterationFor
#!emit ForExpressionInit
#!emit ForExpressionCompare
#!emit ForExpressionIncrement
#!emit ForIterationStatement


#!uid Program 						UID_PROGRAM 						1
#!uid PostfixExpressionValOp 		UID_POSTFIXEXPRESSIONVALOP 			2
#!uid Expression					UID_EXPRESSION						3
#!uid LeftHandSideExpression		UID_LEFTHANDSIDEEXPRESSION			4
#!uid LeftHandSideExpressionAddr	UID_LEFTHANDSIDEEXPRESSIONADDR		5
#!uid DecimalIntegerLiteral			UID_DECIMALINTEGERLITERAL			6
#!uid DecimalNonIntegerLiteral		UID_DECIMALNONINTEGERLITERAL		7
#!uid AdditiveExpressionOp			UID_ADDITIVEEXPRESSIONOP			8
#!uid MultiplicativeExpressionOp	UID_MULTIPLICATIVEEXPRESSIONOP		9
#!uid BitwiseANDOp					UID_BITWISEANDOP					10
#!uid BitwiseXOROp					UID_BITWISEXOROP					11
#!uid BitwiseOROp					UID_BITWISEOROP						12
#!uid ShiftExpressionOp				UID_SHIFTEXPRESSIONOP				13
#!uid EqualityExpressionOp			UID_EQUALITYEXPRESSIONOP			14
#!uid RelationalExpressionOp		UID_RELATIONALEXPRESSIONOP			15
#!uid LogicalOROp					UID_LOGICALOROP						16
#!uid LogicalANDOp					UID_LOGICALANDOP					17
#!uid VariableAllocate				UID_VARIABLEALLOCATE				18
#!uid VariableAllocateAndInit		UID_VARIABLEALLOCATEANDINIT			19
#!uid IdentifierName				UID_IDENTIFIERNAME					20
#!uid Identifier					UID_IDENTIFIER						21
#!uid Initialiser					UID_INITIALISER						22
#!uid AssignmentExpressionOp		UID_ASSIGNMENTEXPRESSIONOP			23
#!uid NewArrayExpression			UID_NEWARRAYEXPRESSION				24
#!uid MemberExpressionDotOp			UID_MEMBEREXPRESSIONDOTOP			25
#!uid MemberExpressionIndexOp		UID_MEMBEREXPRESSIONINDEXOP			26
#!uid FunctionName					UID_FUNCTIONNAME					27
#!uid FunctionDeclaration			UID_FUNCTIONDECLARATION				28
#!uid FunctionParameter				UID_FUNCTIONPARAMETER				29
#!uid FormalParameterList			UID_FORMALPARAMETERLIST				30
#!uid CallExpression				UID_CALLEXPRESSION					31
#!uid FunctionCall					UID_FUNCTIONCALL					32
#!uid Argument						UID_ARGUMENT						33
#!uid Arguments						UID_ARGUMENTS						34
#!uid ReturnStatement				UID_RETURNSTATEMENT					35
#!uid DoubleStringCharacters		UID_STRINGCHARACTERS				36
#!uid SingleStringCharacters		UID_STRINGCHARACTERS				36
#!uid IfStatement					UID_IFSTATEMENT						37
#!uid IfConditionOp					UID_IFCONDITIONOP					38
#!uid IfTrueStatement				UID_IFTRUESTATEMENT					39
#!uid IfFalseStatement				UID_IFFALSESTATEMENT				40
#!uid Block							UID_BLOCK							41
#!uid IterationFor					UID_ITERATIONFOR					42
#!uid ForExpressionInit				UID_FOREXPRESSIONINIT				43
#!uid ForExpressionCompare			UID_FOREXPRESSIONCOMPARE			44
#!uid ForExpressionIncrement		UID_FOREXPRESSIONINCREMENT			45
#!uid ForIterationStatement			UID_FORITERATIONSTATEMENT			46


# 6 Source Text
SourceCharacter			::= .

# 7.2 White space
WhiteSpace				::= [#0x0009] | [#0x000B] | [#0x000C] | [#0x0020] | [#0x00A0] | [#0xFEFF]

# 7.3 Line Terminators
LineTerminator			::= [#0x000D] [#0x000A] | ([#0x000A] | [#0x000D] | [#0x2028] | [#0x2029])
LineTerminatorSequence	::= [#0x000D] [#0x000A] | [#0x000A] | [#0x000D] | [#0x2028] | [#0x2029]
S						::= ( <WhiteSpace> | <LineTerminator> )+
SC						::= <S>? ';' <S>?
COMMA					::= <S>? ',' <S>?
EQ						::= <S>? '=' <S>?

# 7.4 Comments
Comment					::= <MultiLineComment> | <SingleLineComment>
MultiLineComment		::= '/*' <MultiLineCommentChar>* '*/'
MultiLineCommentChar	::= . - '*/'
SingleLineComment		::= '#' <SingleLineCommentChar>*
SingleLineCommentChar	::= <SourceCharacter> - <LineTerminator>

# 7.5 Tokens
Token					::= <IdentifierName> |
			    			<NumericLiteral> |
			    			<StringLiteral>

# 7.6 Identifier Names and Identifiers

Identifier				::= <IdentifierNameNoEmit> - (<ReservedWord> - <ReservedWord> <IdentifierPart>)
IdentifierNoEmit		::= <IdentifierNameNoEmit> - (<ReservedWord> - <ReservedWord> <IdentifierPart>)
IdentifierName			::= <IdentifierStart> <IdentifierPart>*
IdentifierNameNoEmit	::= <IdentifierStart> <IdentifierPart>*
IdentifierStart			::= <UnicodeLetter> | '$' | '_' | '\' <UnicodeLetter>
UnicodeLetter			::= [#0x0041-#0x005A] | [#0x00C0-#0x00DE] | [#0x0100-#0x0232] | [#0x0061-#0x007A] | [#0x00C0-#0x00DE]	    # <Lu> | <Ll>

Lu						::= [#0x0041-#0x005A] | [#0x00C0-#0x00DE] | [#0x0100-#0x0232]  	# TBD
Ll						::= [#0x0061-#0x007A] | [#0x00C0-#0x00DE] 						# TBD
IdentifierPart			::= <IdentifierStart> | 
				    		<UnicodeDigit> 
UnicodeDigit			::= [0-9] | [#0x0660-#0x0669]					# TBD

ReservedWord			::= <NullLiteral> |
							<BooleanLiteral> |
							<Keyword> |
							<FutureReservedWord>

Keyword					::= 'instanceof' | 'typeof'	| 'break' |
			    			'do' | 'new' | 'var' |
			    			'case' | 'else' | 'return' | 'void' | 
			    			'catch' | 'finally' | 'continue' | 'for' | 
			    			'switch' | 'while' | 'this' | 'with' | 
			    			'debugger' | 'function' | 'throw' | 'default' |  
			    			'if' | 'try' | 'delete' | 'in'

FutureReservedWord			::= 'class' | 'enum' | 'extends' | 'import' | 'const' | 'export' |
			    				'implements' | 'let' | 'private' | 'public' |
                            	'static' | 'interface' | 'package' | 'protected'

NullLiteral					::= 'null'
BooleanLiteral 				::= 'true' | 'false'
Literal 					::= <NullLiteral> |
			    				<BooleanLiteral> |
			    				<NumericLiteral> |
			    				<StringLiteral>
			    				
LiteralOp					::= <Literal>

# 7.8.3 Numeric Literals

NumericLiteral					::= <HexIntegerLiteral> | <DecimalNonIntegerLiteral> | <DecimalIntegerLiteral>
DecimalNonIntegerLiteral		::= ('0' | <NonZeroDigit> <DecimalDigits>?) '.' <DecimalDigits>? <ExponentPart>? |
			    					'.' <DecimalDigits> <ExponentPart>? 
DecimalIntegerLiteral			::= '0' | <NonZeroDigit> <DecimalDigits>? <ExponentPart>?
DecimalDigits					::= <DecimalDigit>+
DecimalDigit					::= [0-9]
NonZeroDigit					::= [1-9]
ExponentPart					::= <ExponentIndicator> <SignedInteger>
ExponentIndicator 				::= [eE]
SignedInteger 					::= '-' <DecimalDigits> |
			    					'+' <DecimalDigits> |
			    					<DecimalDigits>
HexIntegerLiteral 				::= '0' [xX] <HexDigit>+
HexDigit 						::= [0-9a-fA-F]

# 7.8.4 String Literals
StringLiteral					::= '"' <DoubleStringCharacters>? '"' |
			    					"'" <SingleStringCharacters>? "'"

DoubleStringCharacters			::= <DoubleStringCharacter>+
SingleStringCharacters			::= <SingleStringCharacter>+

DoubleStringCharacter			::= <SourceCharacter> - ('"' | '\\' | <LineTerminator>)

SingleStringCharacter			::= <SourceCharacter> - ("'" | '\\' | <LineTerminator>)
This							::= 'this'

PrimaryExpression				::= <This> | 
			    					'(' <S>? <Expression> <S>? ')' |
			    					<Literal> |
			    					<Identifier>




ArrayLiteral 					::= '[' <S>? <Elision>? <S>? ']' |
			    					'[' <S>? <ElementList> <S>? ']' |
			    					'[' <S>? <ElementList> <S>? ',' <S>? <Elision> <S>? ']'
ElementList						::= <Elision>? <S>? <AssignmentExpression> (<S>? ',' <S>? <Elision>? <S>? <AssignmentExpression> )*
Elision							::= ',' <S>? <Elision> | <S>? ','


# 11.2 Left-Hand-Side Expressions
LSB								::= <S>? '[' <S>?
RSB								::= <S>? ']' <S>?
MemberExpressionBase			::= <MemberExpression>
MemberExpressionIndexOp			::= <MemberExpressionBase> <LSB> <Expression> <RSB>
MemberExpressionDotOp			::= <MemberExpressionBase> '.' <IdentifierName>

MemberExpression 				::= <MemberExpressionIndexOp>  |
									<MemberExpressionDotOp> |
									<FunctionExpression> |
									<PrimaryExpression>
									
									
NewKeyword						::= 'new' - 'new' <IdentifierPart>
NewArrayExpression				::= <S>? 'new' <S> ( 'Array' | 'Object') <S>? <Arguments>?
NewExpression 					::= <NewArrayExpression> |
									<NewKeyword> <S>? <NewExpression> |
									<MemberExpression>

FunctionCallName				::= <CallExpression> | <MemberExpression>
FunctionCall					::= <FunctionCallName> <S>? <Arguments>
									
CallExpression					::= <CallExpression> <S>? '[' <S>? Expression <S>? ']' |
									<CallExpression> '.' <IdentifierName> |
									<FunctionCall>

Arguments						::= '(' <S>? ')' |
			    					'(' <S>? <ArgumentList> <S>? ')'
Argument						::= <AssignmentExpression>
ArgumentList					::= <ArgumentList> <S>? ',' <S>? <Argument> |
									<Argument>
LeftHandSideExpression			::= <CallExpression> | <NewExpression>
LeftHandSideExpressionAddr		::= <CallExpression> | <NewExpression>


# 11.3 Postfix Expressions
# RULE: LeftHandSideExpression always ends up in R0 (Let see if this would work)
PostfixOperator 				::= '++' | '--'
PostfixExpressionOp 			::= <LeftHandSideExpression> <PostfixOperator>
PostfixExpression 				::= <PostfixExpressionOp> | <LeftHandSideExpression> 

PrefixOperator 					::= '++' | '--'
PrefixExpression 				::= <PrefixOperator> <LeftHandSideExpression>

# 11.4 Unary Operators
UnaryOperator					::= '~' | '!' | ('+' - '++') | ('-' - '--') | 'delete' | 'void' | 'typeof'
UnaryExpressionOp	    		::=	<S>? <UnaryOperator> <S>? <UnaryExpression>
UnaryExpression		    		::=	<UnaryExpressionOp> | <PrefixExpression> | <PostfixExpression>


# 11.5 Multiplicative Operators
MultiplicativeOperator 			::= '*' | '/' | '%'
MultiplicativeExpressionOp		::= <MultiplicativeExpression> <S>? <MultiplicativeOperator> <S>? <UnaryExpression>
MultiplicativeExpression		::= <MultiplicativeExpressionOp> | 
									<UnaryExpression>

# 11.6 Additive Operators
AdditiveOperator 				::= '+' | '-'
AdditiveExpressionOp			::= <AdditiveExpression> <S>? <AdditiveOperator> <S>? <MultiplicativeExpression>
AdditiveExpression				::= <AdditiveExpressionOp> | 
									<MultiplicativeExpression>


11.7 Bitwise Shift Operators
ShiftOperator					::= '>>>' | '<<' | '>>'
ShiftExpressionOp				::= <ShiftExpression> <S>? <ShiftOperator> <S>? <AdditiveExpression>
ShiftExpression					::= <ShiftExpressionOp> |
			    					<AdditiveExpression> 


# 11.8 Relational Operators
RelationalOperator		 		::= '<=' | '>=' | '<' | '>' | 'instanceof'
RelationalExpressionOp			::= <RelationalExpression> <S>? <RelationalOperator> <S>? <ShiftExpression>
RelationalExpression 			::= <RelationalExpressionOp> |
			    					<ShiftExpression>

# 11.9 Equality Operators
EqualityOperator 				::= '===' | '==' | '!==' | '!='
EqualityExpressionOp 			::= <EqualityExpression> <S>? <EqualityOperator> <S>? <RelationalExpression> 
EqualityExpression 				::= <EqualityExpressionOp> |
			    					<RelationalExpression>

BitwiseANDOperator 				::= '&' - '&&'
BitwiseANDOp		 			::= <BitwiseANDExpression> <S>? <BitwiseANDOperator> <S>? <EqualityExpression>
BitwiseANDExpression 			::= <BitwiseANDOp> |
			    					<EqualityExpression>

BitwiseXOROperator 				::= '^'
BitwiseXOROp		 			::= <BitwiseXORExpression> <S>? <BitwiseXOROperator> <S>? <BitwiseANDExpression>
BitwiseXORExpression 			::= <BitwiseXOROp> |
			    					<BitwiseANDExpression>

BitwiseOROperator 				::= '|' - '||'
BitwiseOROp		 				::= <BitwiseORExpression> <S>? <BitwiseOROperator> <S>? <BitwiseXORExpression>
BitwiseORExpression 			::= <BitwiseOROp> |
			    					<BitwiseXORExpression>

# 11.11 Binary Logical Operators
LogicalANDOperator 				::= '&&'
LogicalANDOp		 			::= <LogicalANDExpression> <S>? <LogicalANDOperator>  <S>? <BitwiseORExpression>
LogicalANDExpression 			::= <LogicalANDOp> |
			    					<BitwiseORExpression>

LogicalOROperator 				::= '||'
LogicalOROp			 			::= <LogicalORExpression> <S>? <LogicalOROperator> <S>? <LogicalANDExpression>
LogicalORExpression 			::= <LogicalOROp> |
			    					<LogicalANDExpression>


# 11.12 Conditional Operator ( ? : )
ConditionalExpression 			::= <LogicalORExpression> ( <S>? '?' <S>? <AssignmentExpression> <S>? ':' <S>? <AssignmentExpression> )?

# 11.13 Assignment Operators
AssignmentExpressionOp 			::= <LeftHandSideExpressionAddr> <S>? <AssignmentOperator> <S>? <AssignmentExpression>
AssignmentExpression 			::= <AssignmentExpressionOp> | <ConditionalExpression>
AssignmentOperator 				::= '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|='


# 11.14 Comma Operator 	( , )
Expression    					::= <AssignmentExpression> ( <S>? ',' <S>? <AssignmentExpression> )*


# 12 Statements
Statement						::= <FunctionDeclarationStatement> |
			    					<ExpressionStatement> |
									<ContinueStatement> |
									<Block> |
			    					<Comment> |
			    					<VariableStatement> |
			    					<EmptyStatement> |
			    					<IfStatement> |
			    					<IterationStatement> |
			    					<ContinueStatement> |
			    					<BreakStatement> |
			    					<ReturnStatement> |
			    					<WithStatement> |
			    					<SwitchStatementOp>

# 12.1 Block
Block								::= <S>? '{' <S>? <StatementList>? <S>? '}' <S>?
StatementList						::= (<S>? <Statement>)+

# 12.2 Variable Statement
VariableStatement 					::= 'var' <S>? <VariableDeclarationList> <SC>
VariableDeclarationList 			::= <VariableDeclaration> (<COMMA> <VariableDeclaration> )*
VariableAllocate					::= <IdentifierNoEmit>
VariableAllocateAndInit				::= <IdentifierNoEmit>
VariableDeclaration					::= <VariableAllocateAndInit> <Initialiser> | <VariableAllocate>
Initialiser							::= <EQ> <AssignmentExpression>


# 12.3 Empty Statement
EmptyStatement						::= <SC>

# 12.4 Expression Statement
ExpressionStatement 				::= (<Expression> - ('function' | '{')) <SC>


# 12.5 The if Statement
IfConditionOp						::= 'if' <S>? '(' <S>? <Expression> <S>? ')'
IfTrueStatement						::= <Statement>
IfFalseStatement					::= <Statement>
IfStatement							::= <IfConditionOp> <S>? <IfTrueStatement> <S>? 'else' <S>? <IfFalseStatement> |
			    						<IfConditionOp> <S>? <IfTrueStatement> 

# 12.6 Iteration Statements
# 12.6a Iteration do ... while() 
WhileKeyword						::= 'while'
WhileExpression						::= <WhileKeyword> <S>? '(' <S>? <Expression> <S>? ')'
DoKeyword							::= 'do'
IterationDo							::= <DoKeyword> <S>? <Statement> <S>? <WhileExpression> (<S>? ';')

# 12.6b Iteration while()
WhileConditionOp					::= 'while' <S>? '(' <S>? <Expression> <S>? ')'
IterationWhileOp					::= <WhileConditionOp> <S>? <Statement>

# 12.6c Iteration for ( ; ; )
ExpressionNoIn						::= <Expression>
ForExpressionInit					::= ('var' <S>? <VariableDeclarationList>) | <ExpressionNoIn>
ForExpressionCompare				::= <Expression>
ForExpressionIncrement				::= <Expression>
ForIterationStatement				::= <Statement>
IterationFor						::= 'for' <S>? '(' <S>? <ForExpressionInit>? <S>? ';' <S>? <ForExpressionCompare>? <S>? ';' <S>? <ForExpressionIncrement>? <S>? ')' <S>? <ForIterationStatement>


IterationStatement 					::= <IterationWhileOp> |
										<IterationFor> |
	    								<IterationDo>

# 12.9 The return Statement
ReturnOp							::= ('return' - 'return' <IdentifierPart>) <WhiteSpace>* <AssignmentExpression>? (<S>? ';')
ReturnStatement						::= ('return' - 'return' <IdentifierPart>) <WhiteSpace>* <AssignmentExpression>? (<S>? ';')

# The Break Statement
BreakOp								::= 'break' - 'break' <IdentifierPart>
BreakStatement						::= <S>? <BreakOp> <SC>

# The Continue Statement
ContinueOp							::= 'continue' - 'continue' <IdentifierPart>
ContinueStatement					::= <S>? <ContinueOp> <SC>



# 12.10 The with Statement
WithStatement						::= 'with' <S>? '(' <S>? <Expression> <S>? ')' <S>? <Statement>


# 12.11 The switch Statement
SwitchExpressionOp					::= ('switch' - 'switch' <IdentifierPart>) <S>? '(' <S>? <Expression> <S>? ')'
SwitchStatementOp					::= <SwitchExpressionOp> <S>? <CaseBlock>

CaseBlock							::= '{' <S>? <CaseClauses>? <S>? <DefaultClauseOp>? <S>? <CaseClauses>? <S>? '}' |
				    					'{' <S>? <CaseClauses>? <S>? '}'



CaseClauses 						::= (<S>? <CaseClauseOp>)+
CaseExpressionOp					::= ('case' - 'case' <IdentifierPart>) <S>? <Expression> <S>? ':'
CaseClauseOp						::= <CaseExpressionOp> <S>? <StatementList>?
DefaultKeywordOp					::= 'default' - 'default' <IdentifierPart>
DefaultClauseOp						::= <DefaultKeywordOp> <S>? ':' <S>? <StatementList>?


# 13 Function Definition
FunctionName						::= <IdentifierNoEmit>
FunctionDeclaration					::= ('function'-'function'<IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>?'}'
FunctionExpression					::= ('function'-'function'<IdentifierPart>)<S>?<FunctionName>?<S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>?'}'
FormalParameterList 				::= <FunctionParameter> ( <S>? ',' <S>? <FunctionParameter> )*
FunctionParameter 					::= <IdentifierNoEmit>
FunctionBody						::= <SourceElements>
FunctionDeclarationStatement		::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')' <SC>

# FunctionName						::= <IdentifierNoEmit>
# FunctionNameLookupAlloc			::= <IdentifierNoEmit>
# FunctionDefinition				::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')'
# FunctionDeclaration				::= <FunctionDefinition><S>?'{'<S>?<FunctionBody>?<S>?'}'
# FunctionExpression				::= ('function' - 'function'<IdentifierPart>)<S>?<FunctionName>?<S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>?'}'
# FunctionParameter 				::= <Identifier>
# FormalParameterList 				::= <FunctionParameter> ( <S>? ',' <S>? <FunctionParameter> )*
# FunctionDefinitionStatement		::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionNameLookupAlloc><S>?'('<S>?<FormalParameterList>?<S>?')' <SC>
# FunctionBody						::= <SourceElements>


# 14 Program
SourceElements 					::= (<S>? <SourceElement>)+
SourceElement 						::= <FunctionDeclaration> |
			    						<Statement>
Program							::= <SourceElements>
# The root rule, it is anonymous
<Program>


